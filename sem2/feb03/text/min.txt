Каждый из нас несколько раз писал (или копипастил) такую прекрасную функцию:

void swap(int *pa, int *pb)
{
    int const copy = *pa;
    *pa = *pb;
    *pb = copy;
}
И каждый из нас задумывался о том, что менять местами вообще-то можно не только int-ы.

В языке С++, существует такое понятие, как "перегрузка" функции -- возможность объявить разные функции с одним и тем же именем. Так, можно перегрузить swap, например, для float-ов:

void swap(float *pa, float *pb)
{
    float const copy = *pa;
    *pa = *pb;
    *pb = copy;
}
Идея написать отдельный swap для каждого типа звучит так себе, но очень хочется, чтобы swap можно было вызывать с чем угодно. Специально для этого, в С++ ввели шаблоны функций:
template<typename T>
void swap(T *pa, T *pb)
{
    T const copy = *pa;
    *pa = *pb;
    *pb = copy;
}
https://en.cppreference.com/w/cpp/language/function_template

Шаблон функции -- это не функция в привычном понимании. Это "метафункция" -- её результатом является обычная функция. Иначе говоря, шаблон swap превращает тип T в функцию void(T *, T *). Матановая аналогия функции, которая возвращает другую функцию -- функционал.

Работает это всё примерно так: при вызове swap<int>(pa, pb), компилятор пытается найти "специализацию" шаблона swap с T = int:

template<>
void swap<int>(int *pa, int *pb)
{
    int const copy = *pa;
    *pa = *pb;
    *pb = copy;
}
https://en.cppreference.com/w/cpp/language/template_specialization

Если он эту функцию находит, он просто её вызывает. Если нет, то он находит шаблон, подставляет в него тип T, генерирует специализацию, и потом уже её вызывает: https://cppinsights.io/s/7bcbd1b4

Более того, компилятор может сам "угадывать", чему равен тип T, поэтому вместо swap<int>(pa, pb) можно просто писать swap(pa, pb).

Теперь, swap-ать можно всё, что угодно, и это прекрасно. Такая способность одной функции (даже если она не одна, лишь бы имя совпадало) работать по-разному в зависимости от того, что в неё суёшь, называется полиморфизм. Это основной инструмент создания аккуратных и выразительных абстракций; точнее говоря, без него замучаешься код копипастить.



Нужно реализовать шаблон функций

template<typename T>
T min(T, T);
которые возвращают минимальный из двух переданных им аргументов.

Гарантируется, что для типа T определён bool operator<(T, T);
